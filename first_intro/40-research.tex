\chapter{Исследовательская часть}

\section{Пример работы}

На рисунке \ref{img:work_example} приведен пример работы программы.

\boximg{160mm}{work_example}{Пример работы программы}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item операционная система: Windows 10;
	\item оперативная память: 16 Гб;
	\item процессор: Intel® Core™ i5-8259U.
\end{itemize}

Во время тестирования ноутбук был включен в сеть питания и нагружен только встроенными приложениями окружения и системой тестирования.

\section{Время выполнения реализаций алгоритмов}

 Все реализации алгоритмов сравнивались на случайно сгенерированных строках длиной от 0 до 10 с шагом 1, а те, что используют матрицы расстояний, еще и на строках длиной от 20 до 100 с шагом 10. Так как замеры времени имеют некоторую погрешность, они для каждой длины строк и каждой реализации алгоритма производились 10 раз, а затем вычислялось среднее время работы реализации со строкой.
 
На рисунке \ref{img:time_all} приведены результаты сравнения времени работы всех реализаций. Как видно на графике, реализации, использующие матрицы рассотяний, работают значительно быстрее рекурсивных реализаций без кеширования. Это обусловлено отсутвием в первых вызова функций для вычисления значений, которые уже были подсчитаны ранее.

\img{120mm}{time_all}{Сравнение времени работы реализаций алгоритмов}

 Чтобы получить полную картину, сравним отдельно реализации, использующие матрицы рассотяний, и те, которые их не используют.
 
 На рисунке \ref{img:time_with_matrix} приведено сравнение времени выполнения реализаций итерационного и рекурсивного (с кешированием) алгоритмов поика расстояния Левенштейна. Как видно, время их работы растет соизмеримо, что обусловлено их схожестью в отсутствии вызова функций для вычисления значений, которые уже были подсчитаны ранее. Однако вторая реализация все же работает дольше, так как в ней тратится время на рекурсивный вызов самой себя. 
 
 \img{120mm}{time_with_matrix}{Сравнение времени работы реализациий рекурсивных алгоритмов, использующих матрицы растояний}
 
 На рисунке \ref{img:time_rec_without_cash} приведено сравнение времени выполнения реализаций рекурсивных алгоритмов (без кеширования) поика расстояний Левенштейна и Дамерау-Левенштейна. Эти реализации работали примерно одинаковое количество времени, однако для Дамерау-Левенштейна - немного дольше, так как ему требуется время на подсчет штрафа для дополнительной операции - обмена местами соседних символов.
 
 
 \img{120mm}{time_rec_without_cash}{Сравнение времени работы реализаций рекурсивных алгоритмов, не использующих кеш}
 
 
 %Однако если специально подавать им такие строки, в которых возможна операция обмена соседних символов местами, то алгоритм Дамерау-Левенштейна будет работать дольше, так как ему потребуется время на подсчет штрафа для этой дополнительной операции. Это явление продемонстрировано на рисунке \ref{img:time_dl}. Алгоритмам подавались такие строки: в первой строке n раз повторяется комбинация 'ab', а во второй - n раз 'ba', где n принимает целые значения от 0 до 5.

%\img{120mm}{time_dl}{Сравнение времени работы рекурсивных алгоритмов, не использующих кеш, при особых строках}



\section{Пиковая требуемая алгоритмами память}

Реализации алгоритмов нахождения расстояний Левенштейна и Дамерау—Левенштейна имеют одинаковый подход к использованию памяти. Следовательно, достаточно сравнить, как с увеличением длин строк изменяется пиковая затрачиваемая память в рекурсивных и итерационных реализациях. 

При использовании рекурсивной реализации без кеширования для каждого рекурсивного вызова функции будет необходимо выделять память под локальные переменные, возвращаемое функцией значение, адрес возврата. Максимальная глубина стека вызовов на 2 больше суммы длин исходных строк. Следовательно, пиковая затрачиваемая память растет пропорционально сумме длин строк. 

При использовании итерационной реализайии память в большей степени затрачивается на матрицу расстояний размером  len($S_{1}$) + 1 на len($S_{2}$) + 1. Следовательно, пиковая затрачиваемая память растет пропорционально произведению длин строк, что больше, чем при рекурсивной реализации.

Однако итерационную реализацию можно оптимизировать по памяти, храня лишь последние две строки матрицы расстояний, и тогда пиковая затрачиваемая память будет расти пропорционально изменению длины одной из строк, что меньше, чем при рекурсивной реализации.

Рекурсивные функции с кешированием по этому показателю - худший вариант, так как они потребуют память как под матрицу расстояний (хотя бы в одном экземпляре), так и под стек вызовов.

При небольших длинах строк затрачиваемая память сильно зависит от самой реализации каждого алгоритма (количество локальных переменных, подходы к хранению строк и матриц)

\section*{Вывод}

Реализации алгоритмов нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставимы с реализациями алгоритмом нахождения расстояния Левенштейна, хотя и немного уступают вторым в связи с дополнительной проверкой, позволяющей находить ошибки пользователя, связанные с неверным порядком букв. Однако эта операция зачастую позволяет найти более короткое расстояние между строками.

Рекурсивные реализации алгоритмов нахождения расстояний Левенштейна и Дамерау-Левенштейна, не использующие кеширование, работают на порядок дольше итеративных реализаций. При применении кеширования они требуют меньше времени, однако все равно уступают по производительности итеративным алгоритмам, особенно при большой длине строк. 

Но по расходу памяти итеративные реализации проигрывают рекурсивным: максимальный размер используемой памяти в них пропорционален произведению длин строк, в то время как в рекурсивных — сумме длин строк.

Если же применить к итеративным реализациям оптимизацию по памяти, то они будут выигрывать как по пиковой затрачиваемой памяти, так и по времени выполнения.
